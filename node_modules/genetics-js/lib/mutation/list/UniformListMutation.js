"use strict";
/*
 * @license
 * Copyright (c) 2021 Cristo Navarro.
 * Copyright (c) 2020 Francisco Cruz.
 * Copyright (c) 2019 Cristian Abrante.
 * All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniformListMutation = void 0;
const utils_1 = require("../../generator/utils");
const base_1 = require("../base");
/**
 * ## Uniform List Mutation
 * Base class for mutation operators that are applied to every gene in the
 * ListIndividual.
 *
 * It includes methods to apply the operator to each gene based on a mutation
 * rate, but to define an operator, the method mutateGeneUniformly must be
 * implemented.
 */
class UniformListMutation extends base_1.MutationBase {
    /**
     * Checks if the mutation rate is in range [0.0 - 1.0] and throws an error if
     * it's outside that range.
     * @param mutationRate Mutation rate of the operator
     */
    static checkMutationRate(mutationRate) {
        if (!utils_1.Generator.probabilityIsValid(mutationRate)) {
            throw new Error(`Error: Mutation rate ${mutationRate} is not in range [0.0 - 1.0]`);
        }
    }
    /**
     * Checks if the index is a positive number, and if it isn't, throws an error.
     * @param initialIndex Initial index for the lists
     */
    static checkInitialIndex(initialIndex) {
        if (initialIndex < 0) {
            throw new Error(`Error: Initial index ${initialIndex} can't be smaller than 0.`);
        }
    }
    /**
     * Mutate the especified individual with the given parameters.
     * @param individual Individual to apply the mutation
     * @param mutationRate Rate for the mutation to happen
     * @param initialIndex Initial index for the lists
     * @param engine Generator of random numbers
     */
    mutate(individual, mutationRate = 0.5, initialIndex = 0, engine = utils_1.Generator.DEFAULT_ENGINE) {
        this.mutateWith(individual, { mutationRate, engine, initialIndex });
    }
    /**
     * Mutate the especified individual with the given parameters.
     * @param individual Individual to apply the mutation
     * @param params Parameters for the operator
     */
    mutateWith(individual, params) {
        UniformListMutation.checkInitialIndex(params.initialIndex);
        UniformListMutation.checkMutationRate(params.mutationRate);
        super.mutateWith(individual, params);
    }
    /**
     * Applies the mutation operator to the especified gene of the given
     * individual within a certain probability.
     * @param individual Individual to apply the mutation
     * @param index Index of the gene where the mutation is applied
     * @param params Parameters for the mutation
     */
    mutateGene(individual, index, params) {
        const threshold = utils_1.Generator.generateProbability(params.engine);
        if (threshold <= params.mutationRate) {
            this.mutateGeneUniformly(individual, index, params);
        }
    }
}
exports.UniformListMutation = UniformListMutation;
//# sourceMappingURL=UniformListMutation.js.map