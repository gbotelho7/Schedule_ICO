/**
 * Type for callback that express a condition for each node of the list.
 * @typeparam T type of data stored in the nodes
 */
declare type nodeConditionCallback<T> = (nodeData: T) => boolean;
/**
 * Type for callback executed for each node of the list.
 * @typeparam T type of data stored in the nodes
 */
declare type nodeCallback<T> = (nodeData: T) => any;
/**
 * ## List
 * Class that represents a simple linked list, composed by Nodes.
 *
 * Lists provide methods to easily insert and extract nodes in any position
 * requiring only the data that is going to be inserted.
 *
 * This class provides some 'array-like' methods for iterating over the nodes
 * and modify or access its data.
 *
 * @typeparam T type of data stored in the nodes
 */
export declare class List<T> implements Iterable<T> {
    /**
     * First node of the list.
     */
    private headNode;
    /**
     * Current size of the list.
     */
    private listSize;
    /**
     * Constructor of the class.
     * If data is given, then it creates a node with it and set it to be the first
     * of the list.
     * If no data is given, the head fo the list is set to null.
     * @param headData Data to initialize the first node
     */
    constructor(headData?: T);
    /**
     * Getter to the first node.
     * If the head is not null, it returns the data of the node. If it is null,
     * null is returned instead.
     * @return Data of the first node or null.
     */
    get front(): T | null;
    /**
     * Getter to the last node.
     * If the head is not null, it returns the data of the last node. If it is
     * null, null is returned instead.
     * @return Data of the last node or null.
     */
    get back(): T | null;
    /**
     * Getter of the data of all the nodes.
     * @return Array with the data of every node.
     */
    get values(): T[];
    /**
     * Checks if the list is empty.
     * @return True if it is empty, false if not.
     */
    empty(): boolean;
    /**
     * Access the data of the node in the given position.
     * If the position is out of the range of the list, it throws an error.
     * @param pos Position of the node in the list
     * @return Data of the node.
     */
    get(pos: number): T;
    /**
     * Inserts a node with the given data at the beginning of the list.
     * @param newData Data to insert
     */
    pushFront(newData: T): void;
    /**
     * Erases the first node of the list.
     * If the list is empty, it throws an error.
     */
    popFront(): void;
    /**
     * Inserts a node with the given data at the end of the list.
     * @param newData Data to insert
     */
    pushBack(newData: T): void;
    /**
     * Erases the last node of the list.
     * If the list is empty, it throws an error.
     */
    popBack(): void;
    /**
     * Inserts a new node with the given data in the selected position.
     * If the position is out of the range of the list, an error is thrown.
     * @param pos Posisiton to insert the node
     * @param newData Data of the new node
     */
    insert(pos: number, newData: T): void;
    /**
     * Erases the node at the given position.
     * If the list is empty or the position is out of the range of the list, it
     * throws an error.
     * @param pos Position of the node to be erased
     */
    erase(pos: number): void;
    /**
     * Lists are iterable, so this method returns an iterator.
     * @return Iterator over the nodes of the list.
     */
    [Symbol.iterator](): Iterator<T>;
    /**
     * Gets the current size of the list.
     * @return Size of the list.
     */
    length(): number;
    /**
     * Returns a boolean that is true if every node satisfies the specified
     * condition in the callback function.
     * @param callback Specifies a condition for every node
     * @return True if all nodes accept the condition.
     */
    every(callback: nodeConditionCallback<T>): boolean;
    /**
     * Returns the data of the node that satisfies the condition specified in the
     * callback function. If there isn't a node that accept it, undefined is
     * returned instead.
     * @param callback Specifies the condition that a node must satisfy
     * @return Data of the node that accepts the condition or undefined.
     */
    find(callback: nodeConditionCallback<T>): T | undefined;
    /**
     * Returns the index of the node that satisfies the condition specified in the
     * callback function. If there isn't a node that accept it, undefined is
     * returned instead.
     * @param callback Specifies the condition that a node must satisfy
     * @return Index of the node that accepts the condition or undefined.
     */
    findIndex(callback: nodeConditionCallback<T>): number | undefined;
    /**
     * Executes the specified function for every node of the list.
     * @param callback Function to be executed
     */
    forEach(callback: nodeCallback<T>): void;
    /**
     * Returns a boolean that is true if there is a node in the list that has
     * the same data as which is given.
     * @param data Data to compare
     * @return True if there is a node with the same data, false if not.
     */
    includes(data: T): boolean;
    /**
     * Returns the index of the first node that has the same data as the specified
     * one. If there isn't a node with the same sata, it returns -1.
     * @param data Data of the wanted node
     * @return Index of the wanted node or -1.
     */
    indexOf(data: T): number;
    /**
     * Returns the index of the last node that has the same data as the specified
     * one. If there isn't a node with the same sata, it returns -1.
     * @param data Data of the wanted node
     * @return Index of the wanted node or -1.
     */
    lastIndexOf(data: T): number;
    /**
     * Tests if there is any node that satisfies the specified condition in the
     * callback function.
     * @param callback Specifies the condition for the nodes
     * @return True if there is any node that satisfies the condition
     */
    some(callback: nodeConditionCallback<T>): boolean;
    /**
     * Converts the list to a string.
     * @return String that represents the list.
     */
    toString(): string;
    /**
     * Swap two nodes from the list with the specified positions.
     * @param firstIndex Index of the first node to swap
     * @param secondIndex Index of the second node to swap
     */
    swap(firstIndex: number, secondIndex: number): void;
    /**
     * Swaps the node in the given position with a new one that has the scpecified
     * data.
     * @param index Position of the node to change
     * @param data Data for the new node
     */
    swapWith(index: number, data: T): void;
}
export {};
