"use strict";
/*
 * @license
 * Copyright (c) 2019 Cristian Abrante. All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseIndividual = void 0;
const utils_1 = require("../../utils");
/**
 * ## BaseIndividual
 * Base class for creating individuals which
 * are one of the fundamental blocks of evolutionary
 * algorithms.
 *
 * The fundamental part of the individual is the
 * genotype, which is the array that represents the
 * data of the individual. This genotype is composed
 * of genes.
 *
 * This abstract class provides some 'array-like'
 * methods for iterating over the genes and modify
 * or access its values.
 *
 * @typeparam T is the type of the individual.
 */
class BaseIndividual {
    /**
     * Constructor of the class expects an
     * array for initializing the genotype.
     * @param genotype genotype array.
     */
    constructor(genotype) {
        /**
         * Genotype array.
         */
        this.genotypeArray = [];
        this.setGenotype(genotype);
    }
    /**
     * getter for the genotype.
     * @return genotype array.
     */
    get genotype() {
        return this.genotypeArray;
    }
    /**
     * Individuals are iterable, so this method
     * returns an iterator.
     * @return iterator over the genotype array.
     */
    [Symbol.iterator]() {
        return this.genotype[Symbol.iterator]();
    }
    /**
     * Returns the gene at specified index.
     * @param geneIndex index of the gene to be accessed.
     * @return gene at specified index.
     * @throws RangeError if index is not in range [0-length)
     */
    get(geneIndex) {
        this.checkIndexRange(geneIndex);
        return this.genotype[geneIndex];
    }
    /**
     * Returns the length of the genotype.
     * @return length of the genotype.
     */
    length() {
        return this.genotype.length;
    }
    /**
     * Returns an object iterable iterator whose
     * contains the pairs `[key, value]` for each
     * element.
     * @return iterable iterator object.
     */
    entries() {
        return this.genotype.entries();
    }
    /**
     * Returns a boolean, which is true if all genes
     * in the genotype accept the condition specified
     * in the callback function.
     * @param callback which specifies a condition for all genes.
     * @return `true` if al genes accept condition and `false` otherwise.
     */
    every(callback) {
        return this.genotype.every(callback);
    }
    /**
     * Returns the first element which accepts the condition
     * in the callback.
     * @param callback which specifies the condition.
     * @return first gene which accept the callback condition
     *         or `undefined` if none accepts it.
     */
    find(callback) {
        return this.genotype.find(callback);
    }
    /**
     * Returns the index of the first element which accepts
     * the condition in the callback.
     * @param callback which specifies the condition.
     * @return index of the first gene which accept the
     *         callback condition or `undefined` if none accepts it.
     */
    findIndex(callback) {
        return this.genotype.findIndex(callback);
    }
    /**
     * Executes the callback for each gene
     * of the genotype.
     * @param callback to be executed.
     * @returns `undefined`.
     */
    forEach(callback) {
        this.genotype.forEach(callback);
        return undefined;
    }
    /**
     * Tests if genotype contains specified gene.
     * @param gene to be searched.
     * @param startIndex index to start the search, by default is `0`.
     * @return `true` if gene in genotype or `false` otherwise.
     */
    includes(gene, startIndex = 0) {
        for (let index = startIndex; index < this.genotype.length; index++) {
            if (utils_1.isEqual(this.genotype[index], gene)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the index of the first specified gene.
     * @param gene to be searched.
     * @param fromIndex index to start the search, by default is `0`.
     * @return index of the first specified gene or `-1` if not found.
     */
    indexOf(gene, fromIndex = 0) {
        for (let index = fromIndex; index < this.genotype.length; index++) {
            if (utils_1.isEqual(this.genotype[index], gene)) {
                return index;
            }
        }
        return -1;
    }
    /**
     * Returns an iterator which contains the indexes
     * of the genes.
     * @return iterable iterator of numbers.
     */
    keys() {
        return this.genotype.keys();
    }
    /**
     * Last index of the specified gene in the genotype.
     * The genotype is visited in reverse order.
     * @param gene that we are searching.
     * @param fromIndex from which index to start,
     *        by default is the last index.
     */
    lastIndexOf(gene, fromIndex = this.length() - 1) {
        for (let index = fromIndex; index >= 0; index--) {
            if (utils_1.isEqual(this.genotype[index], gene)) {
                return index;
            }
        }
        return -1;
    }
    /**
     * Test if some gene validates the condition
     * specified by the callback.
     * @param callback that specifies condition.
     * @return `true` if some gene validates condition or
     *         `false` otherwise.
     */
    some(callback) {
        return this.genotype.some(callback);
    }
    /**
     * Converts the individual to string.
     * @return string that represents individual.
     */
    toString() {
        let representation = '';
        this.forEach((gene, index) => {
            representation += this.geneToString(gene) + (index !== this.length() - 1 ? ' ' : '');
        });
        return representation;
    }
    /**
     * Returns an iterator that contains
     * each gene in the genotype.
     * @return iterable iterator that contains each gene.
     */
    values() {
        return this.genotype.values();
    }
    /**
     * Sets the genotype to the specified genotype.
     * @param genotype new genotype.
     */
    setGenotype(genotype) {
        this.genotypeArray = genotype;
    }
    /**
     * Check if index is in range, if not
     * throws an exception.
     * @param index to be checked.
     * @throws RangeError if index is not in range `[0-length]`.
     */
    checkIndexRange(index) {
        if (!this.isInRange(index)) {
            throw new RangeError(`Range Error: Index ${index} is not in range [0 - ${this.length()})`);
        }
    }
    /**
     * Check if index is in range `[0-length]`.
     * @param index to be checked.
     * @return `true` if index is in range and `false` otherwise.
     */
    isInRange(index) {
        return index >= 0 && index < this.length();
    }
}
exports.BaseIndividual = BaseIndividual;
//# sourceMappingURL=BaseIndividual.js.map