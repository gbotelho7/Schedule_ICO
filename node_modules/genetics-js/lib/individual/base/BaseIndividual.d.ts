/**
 * Type for callback that express a condition for each element.
 * @typeparam T type of individual genes.
 */
declare type geneConditionCallback<T> = (gene: T, geneIndex?: number, genotype?: T[]) => boolean;
/**
 * Type for callback executed for each element of the array.
 * @typeparam T type of individual genes.
 */
declare type geneEvaluationCallback<T> = (gene: T, geneIndex?: number, genotype?: T[]) => any;
/**
 * ## BaseIndividual
 * Base class for creating individuals which
 * are one of the fundamental blocks of evolutionary
 * algorithms.
 *
 * The fundamental part of the individual is the
 * genotype, which is the array that represents the
 * data of the individual. This genotype is composed
 * of genes.
 *
 * This abstract class provides some 'array-like'
 * methods for iterating over the genes and modify
 * or access its values.
 *
 * @typeparam T is the type of the individual.
 */
export declare abstract class BaseIndividual<T> implements Iterable<T> {
    /**
     * Genotype array.
     */
    private genotypeArray;
    /**
     * Constructor of the class expects an
     * array for initializing the genotype.
     * @param genotype genotype array.
     */
    constructor(genotype: T[]);
    /**
     * getter for the genotype.
     * @return genotype array.
     */
    get genotype(): T[];
    /**
     * Individuals are iterable, so this method
     * returns an iterator.
     * @return iterator over the genotype array.
     */
    [Symbol.iterator](): Iterator<T>;
    /**
     * Returns the gene at specified index.
     * @param geneIndex index of the gene to be accessed.
     * @return gene at specified index.
     * @throws RangeError if index is not in range [0-length)
     */
    get(geneIndex: number): T;
    /**
     * Returns the length of the genotype.
     * @return length of the genotype.
     */
    length(): number;
    /**
     * Returns an object iterable iterator whose
     * contains the pairs `[key, value]` for each
     * element.
     * @return iterable iterator object.
     */
    entries(): IterableIterator<[number, T]>;
    /**
     * Returns a boolean, which is true if all genes
     * in the genotype accept the condition specified
     * in the callback function.
     * @param callback which specifies a condition for all genes.
     * @return `true` if al genes accept condition and `false` otherwise.
     */
    every(callback: geneConditionCallback<T>): boolean;
    /**
     * Returns the first element which accepts the condition
     * in the callback.
     * @param callback which specifies the condition.
     * @return first gene which accept the callback condition
     *         or `undefined` if none accepts it.
     */
    find(callback: geneConditionCallback<T>): T | undefined;
    /**
     * Returns the index of the first element which accepts
     * the condition in the callback.
     * @param callback which specifies the condition.
     * @return index of the first gene which accept the
     *         callback condition or `undefined` if none accepts it.
     */
    findIndex(callback: geneConditionCallback<T>): number | undefined;
    /**
     * Executes the callback for each gene
     * of the genotype.
     * @param callback to be executed.
     * @returns `undefined`.
     */
    forEach(callback: geneEvaluationCallback<T>): undefined;
    /**
     * Tests if genotype contains specified gene.
     * @param gene to be searched.
     * @param startIndex index to start the search, by default is `0`.
     * @return `true` if gene in genotype or `false` otherwise.
     */
    includes(gene: T, startIndex?: number): boolean;
    /**
     * Returns the index of the first specified gene.
     * @param gene to be searched.
     * @param fromIndex index to start the search, by default is `0`.
     * @return index of the first specified gene or `-1` if not found.
     */
    indexOf(gene: T, fromIndex?: number): number;
    /**
     * Returns an iterator which contains the indexes
     * of the genes.
     * @return iterable iterator of numbers.
     */
    keys(): IterableIterator<number>;
    /**
     * Last index of the specified gene in the genotype.
     * The genotype is visited in reverse order.
     * @param gene that we are searching.
     * @param fromIndex from which index to start,
     *        by default is the last index.
     */
    lastIndexOf(gene: T, fromIndex?: number): number;
    /**
     * Test if some gene validates the condition
     * specified by the callback.
     * @param callback that specifies condition.
     * @return `true` if some gene validates condition or
     *         `false` otherwise.
     */
    some(callback: geneConditionCallback<T>): boolean;
    /**
     * Converts the individual to string.
     * @return string that represents individual.
     */
    toString(): string;
    /**
     * Returns an iterator that contains
     * each gene in the genotype.
     * @return iterable iterator that contains each gene.
     */
    values(): IterableIterator<T>;
    /**
     * Sets the genotype to the specified genotype.
     * @param genotype new genotype.
     */
    protected setGenotype(genotype: T[]): void;
    /**
     * Check if index is in range, if not
     * throws an exception.
     * @param index to be checked.
     * @throws RangeError if index is not in range `[0-length]`.
     */
    protected checkIndexRange(index: number): void;
    /**
     * Check if index is in range `[0-length]`.
     * @param index to be checked.
     * @return `true` if index is in range and `false` otherwise.
     */
    protected isInRange(index: number): boolean;
    /**
     * Converts a gene to string, useful for method
     * `toString`.
     * @param gene that we are converting.
     */
    protected abstract geneToString(gene: T): string;
}
export {};
