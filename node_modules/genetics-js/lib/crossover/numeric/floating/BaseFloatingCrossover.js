"use strict";
/*
 * @license
 * Copyright (c) 2019 Cristian Abrante. All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseFloatingCrossover = void 0;
const utils_1 = require("../../../generator/utils");
const base_1 = require("../../../individual/numeric/base");
const floating_1 = require("../../../individual/numeric/floating");
const base_2 = require("../../base");
class BaseFloatingCrossover extends base_2.BaseCrossover {
    constructor() {
        super(...arguments);
        this.recombinationPoint = 0;
    }
    cross(firstParent, secondParent, alpha = 0.5, engine = utils_1.Generator.DEFAULT_ENGINE) {
        return this.crossWith(firstParent, secondParent, { engine, alpha, individualConstructor: floating_1.FloatingIndividual });
    }
    crossWith(firstParent, secondParent, params) {
        this.generateRecombinationPoint(firstParent.length(), params);
        this.checkParams(params);
        return super.crossWith(firstParent, secondParent, params);
    }
    getGenotypeValues(firstParent, secondParent, params, index) {
        const recombinationCondition = this.getRecombinationCondition(index);
        const firstValue = firstParent.get(index);
        const secondValue = secondParent.get(index);
        return {
            first: recombinationCondition ? this.getRecombinationValue(firstValue, secondValue, params) : firstValue,
            second: recombinationCondition ? this.getRecombinationValue(secondValue, firstValue, params) : secondValue,
        };
    }
    getRecombinationValue(firstParentValue, secondParentValue, params) {
        const { alpha } = params;
        return alpha * firstParentValue + (1.0 - alpha) * secondParentValue;
    }
    checkParams(params) {
        if (!utils_1.Generator.probabilityIsValid(params.alpha)) {
            throw new Error(`BaseFloatingCrossover: alpha of ${params.alpha} is not in range [0.0, 1.0]`);
        }
    }
    generateRecombinationPoint(parentsLength, params) {
        this.recombinationPoint = utils_1.Generator.generateInteger(new base_1.NumericRange(0, parentsLength - 1), params.engine);
    }
}
exports.BaseFloatingCrossover = BaseFloatingCrossover;
//# sourceMappingURL=BaseFloatingCrossover.js.map