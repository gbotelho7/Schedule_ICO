"use strict";
/*
 * @license
 * Copyright (c) 2019 Cristian Abrante. All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NPointsCrossover = void 0;
const utils_1 = require("../../generator/utils");
const base_1 = require("../../individual/numeric/base");
const BaseCrossover_1 = require("./BaseCrossover");
class NPointsCrossover extends BaseCrossover_1.BaseCrossover {
    constructor() {
        super(...arguments);
        this.crossoverPointsRange = base_1.NumericRange.DEFAULT;
        this.crossoverPoints = [];
        this.crossoverPointIndex = 0;
    }
    cross(firstParent, secondParent, numberOfCrossoverPoints, individualConstructor, engine = utils_1.Generator.DEFAULT_ENGINE) {
        return this.crossWith(firstParent, secondParent, {
            engine,
            individualConstructor,
            numberOfCrossoverPoints,
        });
    }
    crossWith(firstParent, secondParent, params) {
        const parentsLength = firstParent.length();
        this.setCrossoverPointsRange(parentsLength);
        this.checkCrossoverParams(params);
        this.generateCrossoverPoints(params);
        this.crossoverPointIndex = 0;
        return super.crossWith(firstParent, secondParent, params);
    }
    getGenotypeValues(firstParent, secondParent, params, index) {
        const crossPoint = this.crossoverPoints[this.crossoverPointIndex];
        if (index >= crossPoint && this.crossoverPointIndex < this.crossoverPoints.length) {
            this.crossoverPointIndex += 1;
        }
        const parentSelectionCondition = this.crossoverPointIndex % 2 === 0;
        return {
            first: parentSelectionCondition ? firstParent.get(index) : secondParent.get(index),
            second: parentSelectionCondition ? secondParent.get(index) : firstParent.get(index),
        };
    }
    setCrossoverPointsRange(parentsLength) {
        this.crossoverPointsRange = new base_1.NumericRange(0, parentsLength - 1);
    }
    checkCrossoverParams(params) {
        if (!base_1.NumericRange.isValueInRange(params.numberOfCrossoverPoints, this.crossoverPointsRange)) {
            throw new Error(`NPointsCrossover: number of crossover points must be in range [${this.crossoverPointsRange.lowest}, ${this.crossoverPointsRange.highest}]`);
        }
    }
    generateCrossoverPoints(params) {
        this.crossoverPoints = [];
        while (this.crossoverPoints.length !== params.numberOfCrossoverPoints) {
            const point = utils_1.Generator.generateInteger(this.crossoverPointsRange, params.engine);
            if (!this.crossoverPoints.includes(point)) {
                this.crossoverPoints.push(point);
            }
        }
        this.crossoverPoints.sort();
    }
}
exports.NPointsCrossover = NPointsCrossover;
//# sourceMappingURL=NPointsCrossover.js.map