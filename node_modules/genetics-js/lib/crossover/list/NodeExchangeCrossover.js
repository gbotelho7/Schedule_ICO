"use strict";
/*
 * @license
 * Copyright (c) 2021 Cristo Navarro.
 * Copyright (c) 2020 Francisco Cruz.
 * Copyright (c) 2019 Cristian Abrante.
 * All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeExchangeCrossover = void 0;
const utils_1 = require("../../generator/utils");
const base_1 = require("../../individual/numeric/base");
const createList_1 = require("../../utils/createList");
const BaseListCrossover_1 = require("./BaseListCrossover");
/**
 * ## NodeExchangeCrossover
 *
 * Class that defines a crossover operator for List Individuals. It is applied
 * to each gene of the parents and exhanges one node selected at random.
 *
 * For the first child, the corresponding gene will be a list with the nodes of
 * the first parent, but one of them will be replaced with one from the second
 * parent. For the second child, it will have the nodes of the second parent but
 * won't have the node that was given to the first one, and instead, it will
 * have the one that was replaced.
 */
class NodeExchangeCrossover extends BaseListCrossover_1.BaseListCrossover {
    /**
     * Calculates the gene of the corresponding index for the new individuals.
     * The first child has the nodes of the first parent, but one of them is
     * replaced with one of the second parent. The same happens to the second
     * child but with the nodes of the second parent.
     * @param firstParent
     * @param secondParent
     * @param params
     * @param index
     */
    getGenotypeValues(firstParent, secondParent, params, index) {
        const firstValues = firstParent.get(index).values;
        const secondValues = secondParent.get(index).values;
        if (this.crossoverIndexes[index][0] >= 0 && this.crossoverIndexes[index][1] >= 0) {
            const aux = firstValues[this.crossoverIndexes[index][0]];
            firstValues[this.crossoverIndexes[index][0]] = secondValues[this.crossoverIndexes[index][1]];
            secondValues[this.crossoverIndexes[index][1]] = aux;
        }
        return {
            first: createList_1.createList(firstValues),
            second: createList_1.createList(secondValues),
        };
    }
    /**
     * Establishes the index for the crossover operator of a given gene. It is
     * calculated based on the legnth of the list corresponding to the indicated
     * gene.
     * @param individual Current individual
     * @param geneIndex Position of the gene in the individual
     * @return Number corresponding to the index for the crossover operator.
     */
    getGeneCrossoverIndex(individual, geneIndex) {
        let crossoverIndex = -1;
        const geneLength = individual.get(geneIndex).length();
        if (geneLength > 1) {
            const geneRange = new base_1.NumericRange(0, geneLength - 1);
            crossoverIndex = utils_1.Generator.generateInteger(geneRange);
        }
        else if (geneLength === 1) {
            crossoverIndex = 0;
        }
        return crossoverIndex;
    }
    /**
     * For each list of both parents, a random index is generated based on the
     * previously calculated range.
     * @param firstParent First individual
     * @param secondParent Second individual
     */
    setCrossoverIndexes(firstParent, secondParent) {
        for (let i = 0; i < firstParent.length(); i++) {
            this.crossoverIndexes[i] = [];
            this.crossoverIndexes[i].push(this.getGeneCrossoverIndex(firstParent, i));
            this.crossoverIndexes[i].push(this.getGeneCrossoverIndex(secondParent, i));
        }
    }
}
exports.NodeExchangeCrossover = NodeExchangeCrossover;
//# sourceMappingURL=NodeExchangeCrossover.js.map