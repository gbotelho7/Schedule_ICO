"use strict";
/*
 * @license
 * Copyright (c) 2019 Cristian Abrante. All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvolutionaryAlgorithm = void 0;
const utils_1 = require("../generator/utils");
const base_1 = require("../individual/numeric/base");
const Population_1 = require("../population/Population");
class EvolutionaryAlgorithm {
    constructor(params) {
        this.generations = 0;
        this.params = params;
        this.population = new Population_1.Population();
        this.population.generatePopulationWithOperations(this.params.populationSize, this.params.generator, this.params.generatorParams, this.params.fitnessFunction);
    }
    run() {
        while (!this.params.terminationCondition.isSatisfied(this.population, this.generations)) {
            this.runGeneration();
        }
    }
    nextGeneration() {
        if (!this.params.terminationCondition.isSatisfied(this.population, this.generations)) {
            this.runGeneration();
        }
    }
    runGeneration() {
        const selectionResult = this.params.selection.selectWith(this.population, this.params.selectionParams);
        const offspring = new Population_1.Population();
        const range = new base_1.NumericRange(0, selectionResult.length - 1);
        while (offspring.getPopulationSize() < this.params.populationSize) {
            const firstIndividual = selectionResult[utils_1.Generator.generateInteger(range)];
            const secondIndividual = selectionResult[utils_1.Generator.generateInteger(range)];
            const xResult = this.params.crossover.crossWith(firstIndividual, secondIndividual, this.params.crossoverParams);
            this.params.mutation.mutateWith(xResult[0], this.params.mutationParams);
            this.params.mutation.mutateWith(xResult[1], this.params.mutationParams);
            offspring.pushIndividual(xResult[0], this.params.fitnessFunction(xResult[0]), 0);
            offspring.pushIndividual(xResult[1], this.params.fitnessFunction(xResult[1]), 0);
        }
        this.population.replacePopulation(this.params.replacement.replace(this.population, offspring, this.params.replacementParams).getPopulationItems());
        this.generations += 1;
    }
}
exports.EvolutionaryAlgorithm = EvolutionaryAlgorithm;
//# sourceMappingURL=EvolutionaryAlgorithm.js.map