"use strict";
/*
 * @license
 * Copyright (c) 2019 Cristian Abrante. All rights reserved.
 * Licensed under the MIT License. See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
// TODO: Better gaussian generator.
const random_js_1 = require("random-js");
const ts_gaussian_1 = require("ts-gaussian");
const base_1 = require("../../individual/numeric/base");
const utils_1 = require("../../individual/numeric/integer/utils");
class Generator {
    static probabilityIsValid(probability) {
        return probability >= 0.0 && probability <= 1.0;
    }
    static generateProbability(engine = Generator.DEFAULT_ENGINE) {
        return this.generateFloating(new base_1.NumericRange(0.0, 1.0), engine);
    }
    static generateBoolean(chance = 0.5, engine = Generator.DEFAULT_ENGINE) {
        this.checkProbability(chance);
        return random_js_1.bool(chance)(engine);
    }
    static generateInteger(range = base_1.NumericRange.DEFAULT, engine = Generator.DEFAULT_ENGINE) {
        const normalizedRange = this.normalizeIntegerRange(range);
        return random_js_1.integer(normalizedRange.lowest, normalizedRange.highest)(engine);
    }
    static generateFloating(range = base_1.NumericRange.DEFAULT, engine = Generator.DEFAULT_ENGINE) {
        return random_js_1.real(range.lowest, range.highest, true)(engine);
    }
    static generateNormalDistributionValue(mean = 0.0, stdVar = 1.0, engine = Generator.DEFAULT_ENGINE) {
        const dist = new ts_gaussian_1.Gaussian(mean, stdVar);
        return dist.ppf(this.generateProbability(engine));
    }
    static generateNormalDistributionInteger(mean = 0, stdVar = 1, engine = Generator.DEFAULT_ENGINE) {
        return utils_1.IntegerNormalizer.normalize(this.generateNormalDistributionValue(mean, stdVar, engine));
    }
    /**
     * This method is used due to an issue with
     * `random-js`. It does not accept `Number.Infinity` as
     *  the lowest or highest number, instead it expects
     *  `2 ** 53` as it maximum or `-2 ** 53` as its minimum.
     *  So the range must be normalized.
     * @param range that we want to normalize.
     * @return normalized range.
     */
    static normalizeIntegerRange(range) {
        const randomJSMax = Math.pow(2, 53);
        const randomJSMin = -randomJSMax;
        const lowest = range.lowest === base_1.NumericRange.DEFAULT.lowest ? randomJSMin : utils_1.IntegerNormalizer.normalize(range.lowest);
        const highest = range.highest === base_1.NumericRange.DEFAULT.highest ? randomJSMax : utils_1.IntegerNormalizer.normalize(range.highest);
        return new base_1.NumericRange(lowest, highest);
    }
    static checkProbability(probability) {
        if (!this.probabilityIsValid(probability)) {
            throw new Error(`Error: probability ${probability} is not in range [0.0, 1.0].`);
        }
    }
}
exports.Generator = Generator;
Generator.DEFAULT_ENGINE = random_js_1.MersenneTwister19937.autoSeed();
//# sourceMappingURL=Generator.js.map